/**
 * @fileabstractXMLparser.cpp
 * @author  Jonas Heiss, Yannic Grafwallner, Ali Guendogan, Elias Keimer, Christoph Gruender
 * @email Christoph@familie-gruender.de
 * @phone 015207619839
 * @date 07/23/2022
 * @version 1.2
 *
 * @section
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * @section DESCRIPTION
 *
 * This C-file was generated by the XML_CPP code generator by Group Immmibase
 */#include "../Hfiles/abstractXMLparser.h" 
#include <getopt.h>

#include <iostream>

using namespace std;


void DHBW::abstractXMLparser::parseOptions(int argc, char **argv) {
workingdir=argv[0];int i;
    int optindex;
bool g_flag = false;bool h_flag = false;bool s_flag = false;bool v_flag = false;
    const struct option longopts[] =
            {{"generate", required_argument, nullptr, 'g'},{"help", no_argument, nullptr, 'h'},{"signperline", required_argument, nullptr, 's'},{"", no_argument, nullptr, 'v'}
};

while ((i = getopt_long(argc, argv, "g:hs:v", longopts, &optindex)) >=0)
switch(i){

case 'g':
 path=argv[argc-1];
g_flag =true;
 break;
case 'h':
h_flag =true;
 break;
case 's':
 signperline=atoi(argv[argc-1]);
s_flag =true;
 break;
case 'v':
v_flag =true;
 break;default:
break;
}

if(g_flag){
if(  h_flag ||v_flag ){
 cout << "Exclusion Error: g" << endl;
 cerr << "Exclusion Error "<<endl;
}else{(generate(path)); }
}if(h_flag){
if(  v_flag ||g_flag ){
 cout << "Exclusion Error: h" << endl;
 cerr << "Exclusion Error "<<endl;
}else{printhelp(); }
}if(s_flag){
if(  g_flag ){
 cout << "Exclusion Error: s" << endl;
 cerr << "Exclusion Error "<<endl;
}else{(signperline); }
}if(v_flag){
if(  h_flag ||g_flag ){
 cout << "Exclusion Error: v" << endl;
 cerr << "Exclusion Error "<<endl;
}else{printversion(); }
}}string DHBW::abstractXMLparser::getValueOfpath(){
if(path!="-"||path!= ""){return path;} return path;
}

bool DHBW::abstractXMLparser::isSetpath() {
    return !(path.empty());
}string helptextformatierung(string text, int signsperline) {
    int space_count = 0;
    bool check = false;
    int count = -1;
    for (int i = 0; i < text.length(); ++i) {
        count++;
        if (text[i] != ' ' && check) {
            space_count++;
        } else if (text[i] == '\n') {
            space_count = 0;
            count = 0;
        } else {
            space_count = 0;
            check = true;
        }
        if (count % signsperline == 0 && i != 0) {
            if (count != signsperline) {
                int index = i - signsperline * (count / signsperline - 1);
                text.insert(index, 1, '-');
                text.insert(index + 1, 1, '\n');
                count = space_count;
            } else {
                text[i - space_count] = '\n';

                count = space_count;
            }
        }
    }
    return text + "\n\n\n";
}void DHBW::abstractXMLparser::printhelp() {
printf("%s", helptextformatierung(helptext,signperline).data());
}bool DHBW::abstractXMLparser::isSethelptext() {
    return !(helptext.empty());
}int DHBW::abstractXMLparser::getValueOfsignperline(){
if(signperline!=79){return signperline;} return signperline;
}

bool DHBW::abstractXMLparser::isSetsignperline() {
    return !(signperline!=79);
}void DHBW::abstractXMLparser::printversion() {
printf("Your current Version is: %s",version.data());
}bool DHBW::abstractXMLparser::isSetversion() {
    return !(version.empty());
}